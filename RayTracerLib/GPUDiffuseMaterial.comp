// glslangValidator.exe -V -e main %(FullPath) -o $(OutDir)\..\bin\%(Filename).comp.spv

#version 450
#extension GL_EXT_debug_printf : enable

layout (push_constant) uniform material_data
{
	uint ID;
	float RandomSeed;
} MaterialData;

struct Intersection
{
	vec4 ray_origin;
	vec4 ray_direction;
	vec4 intersection_location;
	vec4 intersection_normal;
	vec4 ray_color;
	float depth;
	uint object_id;
	uint face_id;
	uint material_id;
	int material_index;
};

layout(std430, set = 0, binding = 0) buffer in_intersections
{
	Intersection intersections[];
} Intersections;

struct Ray
{
	vec4 origin;
	vec4 direction;
	uint pixelXIndex;
	uint pixelYIndex;
};

layout(std430, set = 0, binding = 1) buffer out_resultant_rays
{
	Ray rays[];
} Rays;

struct MaterialParameter
{
	vec4 color;
	float roughness;
};

layout(std430, set = 0, binding = 2) buffer in_material_parameters
{
	MaterialParameter params[];
} MaterialParameters;

float noise(float seed)
{
	return fract(cos(seed));
}

Ray ReflectionRay(MaterialParameter material_parameters, Intersection intersection)
{
	uint gID = gl_GlobalInvocationID.x;

	Ray ray = Rays.rays[gID];

	Ray reflection_ray = Ray(intersection.intersection_location, vec4(0), ray.pixelXIndex, ray.pixelYIndex);
	
	/*
		 ___ ___ a
		 \  |  /
		 r\ |b/ incoming_ray
		   \|/
	*/

	vec4 intersection_normal = intersection.intersection_normal;
	vec4 b = vec4(intersection_normal.xyz, 0.0f) * dot(ray.direction, intersection_normal);
	vec4 a = ray.direction - b;
	vec4 r = normalize((b * -1) + a);

	if(material_parameters.roughness > 0)
	{
		// TODO: jitter based on sample, right now this is the same for every sample
		float random1 = MaterialData.RandomSeed * 2.0 - 1.0;
		float random2 = MaterialData.RandomSeed * 2.0 - 1.0;
		float random3 = MaterialData.RandomSeed * 2.0 - 1.0;
	
		vec4 jittered_refraction_ray = normalize(vec4(random1 + intersection_normal.x, random2 + intersection_normal.y, random3 + intersection_normal.z, 0.0f));
		
		reflection_ray.direction = normalize(mix(r, jittered_refraction_ray, material_parameters.roughness));
	}
	else
	{
		reflection_ray.direction = r;
	}

	return reflection_ray;
}

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint gID = gl_GlobalInvocationID.x;

#ifdef DEBUG
	if(gID == 0)
	{
		debugPrintfEXT("GPU Diffuse Material: %u, %u, %u", Rays.rays.length(), Intersections.intersections.length(), MaterialParameters.params.length());
	}
#endif
	
	if (gID > Intersections.intersections.length())
	{
		return;
	}
	
	Intersection intersection = Intersections.intersections[gID];

	if(intersection.material_id != MaterialData.ID)
	{
		return;
	}

	MaterialParameter material_parameters;
	if(intersection.material_index < 0 || intersection.material_index >= MaterialParameters.params.length())
	{
		material_parameters = MaterialParameter(vec4(0.8f, 0.8f, 0.8f, 1.0f), 0.8f);
	}
	else
	{
		material_parameters = MaterialParameters.params[intersection.material_index];
	}

	intersection.ray_color *= material_parameters.color;
	
	Rays.rays[gID] = ReflectionRay(material_parameters, intersection);
	Intersections.intersections[gID] = intersection;
}
