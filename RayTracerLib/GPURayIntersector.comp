// glslangValidator.exe -V -e main %(FullPath) -o $(OutDir)\..\bin\%(Filename).comp.spv

// TODO: this could be threaded per-ray per-object

#version 450
#extension GL_EXT_debug_printf : enable

//	Incoming data for rays
//		origin (camera origin), direction
//		scene data
//	Outgoing data for rays
//		intersection location, normal, material ID, (eventualy object ID too)

struct Ray
{
	vec4 origin;
	vec4 direction;
	uint pixelXIndex;
	uint pixelYIndex;
};

layout(std430, set = 0, binding = 0) buffer in_rays
{
	Ray rays[];
} Rays;

struct Intersection
{
	vec4 ray_origin;
	vec4 ray_direction;
	vec4 intersection_location;
	vec4 intersection_normal;
	vec4 ray_color;
	float depth;
	uint object_id;
	uint face_id;
	uint material_id;
	uint pixelXIndex;
	uint pixelYIndex;
};

layout(std430, set = 0, binding = 1) buffer out_intersections
{
	Intersection intersections[];
} Intersections;

// Work group layout
layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint gID = gl_GlobalInvocationID.x;

	if(gID == 0)
	{
		debugPrintfEXT("RayIntersectionV2: %u, %u", Rays.rays.length(), Intersections.intersections.length());
	}
	
	if (gID > Rays.rays.length())
	{
		return;
	}
	
	// TODO: Intersect with scene data, this is just filling in world shader info right now
	Intersections.intersections[gID].ray_origin = Rays.rays[gID].origin;
	Intersections.intersections[gID].ray_direction = Rays.rays[gID].direction;
	Intersections.intersections[gID].intersection_location = vec4(0.0f, 0.0f, 0.0f, 0.0f);
	Intersections.intersections[gID].intersection_normal = vec4(0.0f);
	Intersections.intersections[gID].ray_color = vec4(1.0f, 1.0f, 1.0f, 1.0f);
	Intersections.intersections[gID].material_id = 0;
	Intersections.intersections[gID].pixelXIndex = Rays.rays[gID].pixelXIndex;
	Intersections.intersections[gID].pixelYIndex = Rays.rays[gID].pixelYIndex;
}
