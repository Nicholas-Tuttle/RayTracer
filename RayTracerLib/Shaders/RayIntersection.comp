// glslangValidator -V -e main %(FullPath)  -o $(OutDir)\..\bin\%(Filename).comp.spv

#version 450
#extension GL_EXT_debug_printf : enable

#define FLOAT_MAX 0x7f7fffff
#define MM_in_M 1000


// ################################# STRUCTS ################################################################

// The data needed to determine a sphere
struct Sphere
{
	float position[3];
	float radius;
	int material_index;
};

struct Material
{
	float color[3];
	float roughness;
};

struct Color
{
	float color[3];
};

struct RayIntersectionInfo
{
	bool intersects;
	vec3 location;
	vec3 normal;
	float depth;
};

struct Ray
{
	vec3 location;
	vec3 direction;
};









// ########################################### BUFFERS ######################################################

// The number of samples per-pixel
layout(std140, set = 0, binding = 0) uniform sample_count
{
	uint count;
} SampleCount;

// Resolution of the image
layout(std140, set = 0, binding = 1) uniform resolution
{
	uint X;
	uint Y;
} Resolution;

// Data for the camera. Intentionally not using float[]'s because they don't work great with std140
layout(std140, set = 0, binding = 2) uniform camera_data
{
	uint focal_length_mm;
	uint sensor_width_mm;
	float origin_x;
	float origin_y;
	float origin_z;
	float forward_vector_x;
	float forward_vector_y;
	float forward_vector_z;
	float right_vector_x;
	float right_vector_y;
	float right_vector_z;
	float up_vector_x;
	float up_vector_y;
	float up_vector_z;
} CameraData;

// The buffer that contains the scene's spheres
layout(std430, set = 0, binding = 3) buffer spheres
{
	Sphere InputValues[];
} Spheres;

layout(std430, set = 0, binding = 4) buffer materials
{
	Material InputValues[];
} Materials;

// The final output colors for the pixels
layout(std430, set = 0, binding = 5) buffer output_pixel_colors
{
	Color Colors[];
} OutputPixelColors;

// Work group layout
layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;








// ############################################ FUNCTIONS ###################################################

Material DefaultMaterial()
{
	Material material;
	material.color = float[](1.0, 0.0, 1.0);
	material.roughness = 0.5;
	return material;
}

Material GetMaterial(int material_index)
{
	if(material_index < 0 || material_index >= Materials.InputValues.length())
	{
		return DefaultMaterial();
	}
	else
	{
		return Materials.InputValues[material_index];
	}
}

RayIntersectionInfo ray_intersects_sphere(Ray ray, Sphere sphere)
{
	RayIntersectionInfo info;
	info.intersects = false;
	info.normal = vec3(0.0, 0.0, 0.0);

	vec3 sphere_position = vec3(sphere.position[0], sphere.position[1], sphere.position[2]);

	vec3 line_origin_to_sphere_center_O_minus_C = sphere_position - ray.location;
	float u_dot = dot(line_origin_to_sphere_center_O_minus_C, normalize(ray.direction));

	float dot_squared = u_dot * u_dot;
	float magnitude_squared = dot(line_origin_to_sphere_center_O_minus_C, line_origin_to_sphere_center_O_minus_C);
	float radius_squared = sphere.radius * sphere.radius;
	
	float delta = dot_squared + radius_squared - magnitude_squared;
	
	if (delta < 0)
	{
		return info;
	}

	// The closest depth has to be the "minus" term of the "plus or minus" square-root since delta is always positive
	float depth = u_dot - sqrt(delta);
	
	// If the depth is negative either only the backwards ray intersects, or it is a backface from starting in the sphere
	if (depth < 0)
	{
		return info;
	}

	info.intersects = true;

	vec3 intersection_location = ray.location + normalize(ray.direction) * depth;
	vec3 intersection_normal = normalize((intersection_location - sphere_position));

	info.location = intersection_location;
	info.normal = intersection_normal;
	info.depth = depth;

	return info;
}

float noise(float seed)
{
	return fract(cos(seed));
}

vec3 MaterialColor(int material_index)
{
	Material material = GetMaterial(material_index);
	return vec3(material.color[0], material.color[1], material.color[2]);
}

Ray ReflectionRay(Ray incoming_ray, RayIntersectionInfo intersection_info, int material_index, int sample_index)
{
	/*
		 ___ ___ a
		 \  |  /
		 r\ |b/ incoming_ray
		   \|/
	*/

	Ray outgoing_ray = Ray(vec3(0), vec3(0));

	vec3 intersection_normal = intersection_info.normal;
	vec3 b = intersection_normal * dot(incoming_ray.direction, intersection_normal);
	vec3 a = incoming_ray.direction - b;
	vec3 r = normalize((b * -1) + a);

	Material material = GetMaterial(material_index);

	if(material.roughness > 0)
	{
		float random1 = noise((269 *  sample_index + gl_GlobalInvocationID.x) % 211) * 2.0 - 1.0;
		float random2 = noise((271 *  sample_index + gl_GlobalInvocationID.x) % 223) * 2.0 - 1.0;
		float random3 = noise((277 *  sample_index + gl_GlobalInvocationID.x) % 227) * 2.0 - 1.0;
	
		vec3 jittered_refraction_ray = normalize(vec3(
			random1 + intersection_normal.x, 
			random2 + intersection_normal.y, 
			random3 + intersection_normal.z));
		
		outgoing_ray.direction = normalize(mix(r, jittered_refraction_ray, material.roughness));
	}
	else
	{
		outgoing_ray.direction = r;
	}

	outgoing_ray.location = intersection_info.location;

	return outgoing_ray;
}

vec3 WorldColor(float angle)
{
	if(angle > 0)
	{
		return vec3(0.7, 0.9, 1.0);
	}
	else
	{
		return vec3(0.6, 0.3, 0.15);
	}
}

vec3 TraceRay(Ray incoming_ray, int sample_index)
{
	const uint max_bounces = 10;
	uint total_bounces = 0;

	vec3 current_sample_color = vec3(1.0);

	bool at_least_one_intersected = false;
	float min_depth = FLOAT_MAX;
	Ray traced_ray = incoming_ray;

	do
	{
		bool object_intersected_this_ray = false;
		float min_depth = FLOAT_MAX;
		Ray min_depth_ray = Ray(vec3(0), vec3(0));
		vec3 min_depth_color = vec3(0);

		for(int sphere_index = 0; sphere_index < Spheres.InputValues.length(); sphere_index++)
		{
			RayIntersectionInfo intersection_info = ray_intersects_sphere(traced_ray, Spheres.InputValues[sphere_index]);
			
			if(intersection_info.intersects)
			{
				if(intersection_info.depth < min_depth)
				{
					min_depth = intersection_info.depth;
					min_depth_color = MaterialColor(Spheres.InputValues[sphere_index].material_index);
					min_depth_ray = ReflectionRay(traced_ray, intersection_info, Spheres.InputValues[sphere_index].material_index, sample_index);
				}

				object_intersected_this_ray = true;
			}
		}
		
		at_least_one_intersected = object_intersected_this_ray;

		if(object_intersected_this_ray)
		{
			traced_ray = min_depth_ray;
			current_sample_color *= min_depth_color;
		}
		else
		{
			// Intersect with the world
			current_sample_color *= WorldColor(traced_ray.direction.y);
			// Don't check for more intersections
			break;
		}

		total_bounces++;
		if (total_bounces == max_bounces)
		{
			// Use the world ambient color
			current_sample_color *= vec3(0.1, 0.1, 0.1);
			break;
		}
	} 
	while(at_least_one_intersected);

	return current_sample_color;
}







// ############################################ MAIN ########################################################

void main()
{
	uint gID = gl_GlobalInvocationID.x;

	if(gID == 0)
	{
		debugPrintfEXT("Running Main");
	}

	if (gID > OutputPixelColors.Colors.length())
	{
		return;
	}

	vec3 output_color = vec3(0.0, 0.0, 0.0);
	uint resolution_x = uint(Resolution.X);
	uint resolution_y = uint(Resolution.Y);

	const uint pixel_x_index = gID % resolution_x;
	const uint pixel_y_index = gID / resolution_x;
	
	const vec3 camera_origin = vec3(CameraData.origin_x, CameraData.origin_y, CameraData.origin_z);
	const vec3 camera_forward_vector = normalize(vec3(CameraData.forward_vector_x, CameraData.forward_vector_y, CameraData.forward_vector_z));
	const vec3 camera_right_vector = vec3(CameraData.right_vector_x, CameraData.right_vector_y, CameraData.right_vector_z);
	const vec3 camera_up_vector = normalize(vec3(CameraData.up_vector_x, CameraData.up_vector_y, CameraData.up_vector_z));
	const vec3 center_of_near_clip_plane = vec3(camera_origin + (camera_forward_vector * (float(CameraData.focal_length_mm) / MM_in_M)));
	
	const float camera_sensor_width_m = float(CameraData.sensor_width_mm) / MM_in_M;
	const float horizontal_scalar = ((float(((2 * pixel_x_index) + 1)) / resolution_x) - 1) * camera_sensor_width_m;
	const float camera_sensor_height_m = float(CameraData.sensor_width_mm * resolution_y) / MM_in_M / resolution_x;
	const float vertical_scalar = ((float((-1 * int(((2 * pixel_y_index) + 1)))) / resolution_y) + 1) * camera_sensor_height_m;
	vec3 central_ray = center_of_near_clip_plane + (camera_right_vector * horizontal_scalar) + (camera_up_vector * vertical_scalar) - camera_origin;
	
	float pixel_width_m = camera_sensor_width_m / resolution_x;
	float pixel_height_m = pixel_width_m;

	vec3 rightVector;
	vec3 upVector;
	if(central_ray == vec3(0, 1, 0))
	{
		rightVector = vec3(1, 0, 0);
		upVector = vec3(0, 1, 0);
	}
	else
	{
		rightVector = normalize(cross(central_ray, vec3(0, 1, 0)));
		upVector = normalize(cross(rightVector, central_ray));
	}
	
	for(int sample_index = 0; sample_index < SampleCount.count; sample_index++)
	{
		// Get a jittered ray
		float random1 = noise(269 *  sample_index + 13) - 0.5;
		float random2 = noise(271 *  sample_index + 17) - 0.5;
		vec3 ray_direction = central_ray + (rightVector * random1 * pixel_width_m) + (upVector * random2 * pixel_height_m);
		Ray ray = Ray(camera_origin, ray_direction);

		output_color += TraceRay(ray, sample_index);
	}
	
	output_color /= SampleCount.count;
	
	OutputPixelColors.Colors[gID].color[0] = output_color.x;
	OutputPixelColors.Colors[gID].color[1] = output_color.y;
	OutputPixelColors.Colors[gID].color[2] = output_color.z;
}
